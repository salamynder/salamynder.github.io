<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>2019-12-07-js-async-compilation - René Tobner</title>
        <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
        <link rel="stylesheet" type="text/css" href="/css/hemingway.css" />
        <link rel="stylesheet" type="text/css" href="/css/white.css" />
        <link rel="stylesheet" type="text/css" href="/css/icons.css" />
    </head>
    <body>
        <div id="header">
            <div class="inside nocontent">
                <div id="me"><h2><a href="/">René Tobner</a></h2></div>
                <div class="links">
                    <a id="email" class="toplink" target="_blank"><span class="icon-mail"></span></a>
                    <a href="http://github.com/salamynder/" class="toplink" target="_blank"><span class="icon-github"></span></a>
                </div>
                <!-- <div class="links top-search-icon"> -->
                <!--     <a href="/search.html" class="toplink"><span class="icon-search"></span></a> -->
                <!-- </div> -->
                <div class="clear"></div>
            </div>
        </div>

        <div id="primary">
    <div class="inside">
        <h1 class="title">2019-12-07-js-async-compilation</h1>
        <div class="opacity08"><small>
                <i>December  7, 2019 / </i>
        </small></div>
        <br>
        <h1 id="notes-on-js-async-operations">Notes on JS async operations</h1>
<h2 id="tldr">tl;dr</h2>
<p>Async/await works by making a generator check a promis for settlement (settle: Did the promise resolve to a value or reject with an error, yet?). (<a href="#gen-prom-check">gen-prom-check</a>)</p>
<p>If targeting js-environments without native generator implementation,</p>
<ul>
<li>there is a <a href="https://www.npmjs.com/package/regenerator-runtime">generator runtime for async operations</a> by facebook. Async code needs to be transpiled via the <a href="https://github.com/facebook/regenerator">regenerator</a> library.</li>
<li>TODO: this approach seems to be used with react-native (<a href="https://github.com/facebook/regenerator/issues/375">bug-breaking-react-native</a>)
<ul>
<li>Why used at all? More efficient than Promise-only translation, see below?</li>
<li>related: <a href="https://github.com/babel/babel/issues/8121">async-to-promise-rather-than-async-to-generator</a></li>
</ul></li>
</ul>
<p>However, async/await can also be transpiled to pure promises via `babel-plugin-async-to-promises`. (<a href="#promise-only">promise-only</a>)</p>
<h2 id="intro">Intro</h2>
<p>In languages which block script execution when IO-operations are being done, there is no problem to simply embed these operations in your method chains, like here in PHP where `doRequest` (1) is a method simulating a network request:</p>
<h2 id="php-blocking">PHP-&gt;blocking</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode php"><code class="sourceCode php"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">$w</span> = <span class="kw">new</span> Work <span class="ot">(</span><span class="kw">$data</span><span class="ot">);</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">$w</span>-&gt;selectSubset<span class="ot">(</span><span class="dv">0</span><span class="ot">)</span> <span class="co">//working on Mario</span></a>
<a class="sourceLine" id="cb1-3" title="3">  -&gt;prepareQuery<span class="ot">()</span></a>
<a class="sourceLine" id="cb1-4" title="4">  -&gt;doRequest<span class="ot">()</span>     <span class="co">// (1) sleeps a bit / blocks until execution is finished</span></a>
<a class="sourceLine" id="cb1-5" title="5">  -&gt;logResult<span class="ot">()</span>     <span class="co">// next method can be called!</span></a>
<a class="sourceLine" id="cb1-6" title="6">  -&gt;processResult<span class="ot">();</span></a></code></pre></div>
<h2 id="js-asyncawait-non-blocking">JS: async/await, non-blocking</h2>
<p>Doing the same in languages which by default do not block on IO, like javascript runtimes, was quite daunting until async/await keywords of ES7 (node v7.6.0) have arrived. (Before that you had to rely on passing callbacks to functions, or registering the callback via `Promise.then()`.) For example, a one-to-one naive translation of the PHP code above results in the following (Spoiler: which is not going to work, because `doRequest` is called without await operator…):</p>
<div class="sourceCode" id="cb2" data-org-language="js"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">let</span> w <span class="op">=</span> <span class="kw">new</span> <span class="at">Work</span> (data)</a>
<a class="sourceLine" id="cb2-2" title="2">    .<span class="at">selectSubset</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb2-3" title="3">    .<span class="at">prepareQuery</span>()</a>
<a class="sourceLine" id="cb2-4" title="4">    .<span class="at">doRequest</span>()     <span class="co">// (1) is already async function, see below</span></a>
<a class="sourceLine" id="cb2-5" title="5">    .<span class="at">logResult</span>()</a>
<a class="sourceLine" id="cb2-6" title="6">    .<span class="at">processResult</span>()</a></code></pre></div>
<p>Where `doRequest` looks like this:</p>
<div class="sourceCode" id="cb3" data-org-language="js"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> Work</a>
<a class="sourceLine" id="cb3-2" title="2">    [...]</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">async</span> <span class="at">doRequest</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="kw">function</span> <span class="at">get</span>(uri)<span class="op">{</span></a>
<a class="sourceLine" id="cb3-6" title="6">            <span class="cf">return</span> <span class="kw">new</span> <span class="at">Promise</span>((resolve<span class="op">,</span>reject) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8">                <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-9" title="9">                    <span class="cf">if</span> (uri<span class="op">===</span><span class="st">'Mario'</span>)</a>
<a class="sourceLine" id="cb3-10" title="10">                        <span class="at">resolve</span>(<span class="st">&quot;It'seh meeeh, Mario!&quot;</span>)</a>
<a class="sourceLine" id="cb3-11" title="11">                    <span class="cf">else</span> </a>
<a class="sourceLine" id="cb3-12" title="12">                        <span class="at">resolve</span>(<span class="st">&quot;Evil twin detected! )=D&quot;</span>)</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">                <span class="op">},</span> <span class="dv">1000</span>)</a>
<a class="sourceLine" id="cb3-15" title="15">            <span class="op">}</span>)</a>
<a class="sourceLine" id="cb3-16" title="16">        <span class="op">}</span></a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18">        <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`:: Requesting &gt;</span><span class="sc">${</span><span class="kw">this</span>.<span class="at">uri</span><span class="sc">}</span><span class="vs">&lt;`</span>)</a>
<a class="sourceLine" id="cb3-19" title="19"></a>
<a class="sourceLine" id="cb3-20" title="20">        <span class="kw">let</span> res <span class="op">=</span> <span class="cf">await</span> <span class="at">get</span>(<span class="kw">this</span>.<span class="at">uri</span>)     <span class="co">// (2) wait</span></a>
<a class="sourceLine" id="cb3-21" title="21">        <span class="kw">this</span>.<span class="at">res</span> <span class="op">=</span> res                    <span class="co">// (3) store in instance variable</span></a>
<a class="sourceLine" id="cb3-22" title="22"></a>
<a class="sourceLine" id="cb3-23" title="23">        <span class="co">// (4) log the result</span></a>
<a class="sourceLine" id="cb3-24" title="24">        <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`:: Response for &gt;</span><span class="sc">${</span><span class="kw">this</span>.<span class="at">uri</span><span class="sc">}</span><span class="vs">&lt; arrived: `</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">res</span><span class="op">,</span> <span class="st">' (from doRequest() )'</span>)</a>
<a class="sourceLine" id="cb3-25" title="25"></a>
<a class="sourceLine" id="cb3-26" title="26">        <span class="cf">return</span> <span class="kw">this</span></a>
<a class="sourceLine" id="cb3-27" title="27">    <span class="op">}</span></a>
<a class="sourceLine" id="cb3-28" title="28">    [...]</a></code></pre></div>
<p>So, this will not work out, because, as already stated, the default execution model is non-blocking (asynchronous) and this is not going to change.</p>
<p>The output of the above code is the following, showing that the logging from `doRequest` ((4) above) comes much too late:</p>
<pre class="example"><code>:: Requesting &gt;Mario&lt;
:: query result:  null (from .logResult)
:: merging query result with data....
[ { user: 'Mario', verdict: null }, { user: 'Wario' } ]
:: Done!
====================

:: Response for &gt;Mario&lt; arrived:  It'seh meeeh, Mario!  (from doRequest() )
</code></pre>
<p>Since all async functions implicitly return a Promise, the Promise is resolved eventually, but in the meantime the code after `doRequest` has already run.</p>
<p>Now, async/await, as used in doRequest, gives the possibility to suspend the current function via `await` (2), but why is not working, yet?</p>
<p><span id="async-context"></span></p>
<p>The reason is that the JS runtime doesn’t know about the async nature of `doRequest`, when it is called as a regular function at the top-level of your module/script, and to make the async nature clear, `doRequest` has to be awaited for. Since `await` is only allowed<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> in functions declared async, we gonna wrap everything with some `async function` (1) and `await` (2) the async calls, as seen below:</p>
<div class="sourceCode" id="cb5" data-org-language="js"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">async</span> <span class="kw">function</span> <span class="at">run</span> ()<span class="op">{</span>     <span class="co">// (1)</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="kw">let</span> w <span class="op">=</span> <span class="kw">new</span> <span class="at">Work</span> (data)</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="co">//working on Mario</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="va">w</span>.<span class="at">selectSubset</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="va">w</span>.<span class="at">prepareQuery</span>()</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="cf">await</span> <span class="va">w</span>.<span class="at">doRequest</span>()    <span class="co">// (2) now it really waits</span></a>
<a class="sourceLine" id="cb5-11" title="11"></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="va">w</span>.<span class="at">logResult</span>()          <span class="co">// (3) can log the result of (2)</span></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="va">w</span>.<span class="at">processResult</span>()</a>
<a class="sourceLine" id="cb5-14" title="14"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="at">run</span>()</a></code></pre></div>
<p>So, sadly the method chain is broken up but it works as intended … AND since `await` only suspends the `run` function, node/javascript can still do other things in between, for example updating a counter via:</p>
<div class="sourceCode" id="cb6" data-org-language="js"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// [... same as before]</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">let</span> cnt <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">let</span> i <span class="op">=</span> <span class="at">setInterval</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="cf">if</span>(cnt <span class="op">===</span> <span class="dv">15</span>)</a>
<a class="sourceLine" id="cb6-5" title="5">        <span class="at">clearInterval</span>(i)</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;++ working on counter :&quot;</span><span class="op">,</span>cnt<span class="op">++</span>)</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="op">},</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="at">run</span>()</a></code></pre></div>
<p>will yield:</p>
<pre class="example"><code>:: input data: 
 [ { user: 'Mario' }, { user: 'Wario' } ]
:: Requesting &gt;Mario&lt;                                     (1)
++ working on counter : 1
++ working on counter : 2
++ working on counter : 3
++ working on counter : 4
++ working on counter : 5
++ working on counter : 6
++ working on counter : 7
++ working on counter : 8
++ working on counter : 9
:: Response for &gt;Mario&lt; arrived:  It'seh meeeh, Mario!    (2)
:: query result:  It'seh meeeh, Mario! (from .logResult)
:: merging query result with data....
[ { user: 'Mario', verdict: 'It\'seh meeeh, Mario!' },
  { user: 'Wario' } ]
:: Done!
====================
</code></pre>
<p>As one can see, after making the request (1) node can do some other work, our code seems to be suspended, awaiting the response, until finally (2) the response is logged from `doRequest` and one line later from the `logResult` method and so on. Therefore we have a means to write synchronous looking code, while the efficiency of node’s default asynchronous, non-blocking execution model is preserved.</p>
<p><span id="gen-prom-check"></span></p>
<h2 id="generators-and-promises-as-aequivalence-of-asyncawait">Generators and Promises as aequivalence of async/await</h2>
<p>Since babel transpiles async/await code to generators which are specialized to yield promises, as you can see here:</p>
<ul>
<li><a href="https://babeljs.io/repl/#?babili%3Dfalse&amp;browsers%3D&amp;build%3D&amp;builtIns%3Dfalse&amp;spec%3Dfalse&amp;loose%3Dfalse&amp;code_lz%3DIYZwngdgxgBAZgV2gFwJYHsIwDboOYBiApslABYAUCATtgJQwDeAUDDMtWE62zFJiGQxqREAAcBRGAF4YwAO7BUQuCXJVadANw82_CCHTYiAOlx4KCpUJHjJJ5EQAeyCnW08AvjyjBSZGAoiamoGFl4-ASNTcwoAclV_eCVjABM4gBoYYNCdNm9PIA&amp;debug%3Dfalse&amp;forceAllTransforms%3Dfalse&amp;shippedProposals%3Dfalse&amp;circleciRepo%3D&amp;evaluate%3Dtrue&amp;fileSize%3Dfalse&amp;timeTravel%3Dfalse&amp;sourceType%3Dmodule&amp;lineWrap%3Dfalse&amp;presets%3Des2017&amp;prettier%3Dfalse&amp;targets%3D&amp;version%3D7.7.4&amp;externalPlugins%3D">async-await-2-gen-promise</a></li>
</ul>
<p>the two constructs are at least equivalent. See <a href="https://github.com/salamynder/simple-async-data-pipeline/blob/289b5dd/async-to-generator.js">this file</a> in my repo for elucidating logging.</p>
<p>Another article dealing with the aequivalence:</p>
<dl>
<dt>simple async implementation using generators and promises</dt>
<dd><a href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2">hackernoon/async-await-generators-promises</a>
</dd>
</dl>
<p>Also, async/await should be internally implemented using generators, as hinted at here: <a href="https://exploringjs.com/es6/ch_generators.html#sec_overview-generators">exploringjs/generators-overview</a> (“ECMAScript 2017 will have async functions which are internally based on generators.”)</p>
<h3 id="implementation-of-generators-and-asyncawait-in-v8"><span class="todo TODO">TODO</span> Implementation of generators and async/await in V8?</h3>
<h2 id="generators-semi-coroutines-shallow-coroutines">Generators = semi-coroutines, shallow coroutines</h2>
<h3 id="coroutines-wikicoroutine">Coroutines? (<a href="https://en.wikipedia.org/wiki/Coroutine">Wiki/Coroutine</a>)</h3>
<ul>
<li>“allowing execution to be suspended and resumed”
<ul>
<li>= they have some sort `yield` mechanism</li>
</ul></li>
<li>“generalize subroutines”
<ul>
<li>= any coroutine can be converted into a subroutine by not calling `yield`</li>
</ul></li>
<li>“for non-preemptive multitasking”
<ul>
<li>= cooperative multitasking: “a style of computer multitasking in which the operating system never initiates a context switch from a running process to another process. Instead, processes voluntarily <strong>yield</strong> control […]” (my emphasis, see <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">Wiki/CoopMultitasking</a>)</li>
</ul></li>
</ul>
<h3 id="generators-vs.-coroutines-fibers">Generators vs. Coroutines (fibers)</h3>
<p>From <a href="https://github.com/yortus/asyncawait/issues/51">https://github.com/yortus/asyncawait/issues/51</a> (asyncawait is a node.js package using node-fibers; fibers are a system level construct, namely cooperrative threads, which is <strong>equivalent</strong> to the language level construct of coroutines):</p>
<p>“Fibers and <strong>coroutines</strong> support deep continuations. This means that you can yield at any depth in the call stack and resume there later.”</p>
<p>Example from the same thread:</p>
<div class="sourceCode" id="cb8" data-org-language="js"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">let</span> testFn <span class="op">=</span> <span class="kw">async</span> (() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3">    someArray <span class="op">=</span> [...]<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="kw">let</span> results <span class="op">=</span> someArray</a>
<a class="sourceLine" id="cb8-6" title="6">        .<span class="at">filter</span>(el <span class="kw">=&gt;</span> <span class="cf">await</span> (<span class="at">someAsyncTest</span>())   <span class="co">// (1)</span></a>
<a class="sourceLine" id="cb8-7" title="7">        .<span class="at">map</span>(el <span class="kw">=&gt;</span> <span class="cf">await</span> (<span class="at">someAsyncMapping</span>())<span class="op">;</span>  <span class="co">// (2)</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="cf">return</span> results<span class="op">;</span></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>With the package `asyncawait`, it is unnecessary to give filter or map (1,2) an `async` callback. To achieve the same with regular async/await, you’d have to sprinkle a lot more async/await operators and use `Promise.all`:</p>
<div class="sourceCode" id="cb9" data-org-language="js"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">let</span> testFn <span class="op">=</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">let</span> someArray <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="kw">let</span> results <span class="op">=</span> <span class="cf">await</span> <span class="va">Promise</span>.<span class="at">all</span> (</a>
<a class="sourceLine" id="cb9-6" title="6">        someArray</a>
<a class="sourceLine" id="cb9-7" title="7">            .<span class="at">map</span>(<span class="kw">async</span> el <span class="kw">=&gt;</span> <span class="cf">await</span> el <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-8" title="8">    )</a>
<a class="sourceLine" id="cb9-9" title="9"></a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="cf">return</span> results<span class="op">;</span></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="op">};</span></a>
<a class="sourceLine" id="cb9-12" title="12"></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="kw">async</span> <span class="kw">function</span> <span class="at">run</span> ()<span class="op">{</span></a>
<a class="sourceLine" id="cb9-14" title="14"></a>
<a class="sourceLine" id="cb9-15" title="15">    <span class="kw">let</span> res <span class="op">=</span> <span class="cf">await</span> <span class="at">testFn</span>()</a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="va">console</span>.<span class="at">log</span>(res)</a>
<a class="sourceLine" id="cb9-17" title="17"><span class="op">}</span></a>
<a class="sourceLine" id="cb9-18" title="18"></a>
<a class="sourceLine" id="cb9-19" title="19"><span class="at">run</span>() <span class="co">// -&gt; [2,3,4,5]</span></a></code></pre></div>
<p>“Generators only support single frame continuations. This means that yielding only saves 1 stack frame. This is less powerful and it explains why you need to yield (or await) at all levels when you use generators (or ES7 async/await) to streamline async call graphs.” (again <a href="https://github.com/yortus/asyncawait/issues/51">https://github.com/yortus/asyncawait/issues/51</a> )</p>
<p>This explains the top-level-await for my `doRequest` above (and the async-function-wrapper). Generators are simply not powerful enough, and this seems to be quite reasonable for running in your browser tab (while node-fibers is still very active!)</p>
<p>Related discussion:</p>
<dl>
<dt><a href="https://exploringjs.com/es6/ch_generators.html#sec_generators-are-shallow">exploringJS-shallow-generators</a></dt>
<dd>but preserving run-to-completion
</dd>
<dt><a href="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/">why-coroutines-wont-work-on-the-web</a></dt>
<dd>“coroutines no, generators yes”
</dd>
</dl>
<h2 id="promise-translation-of-asyncawait-actions">Promise translation of async/await actions</h2>
<div class="sourceCode" id="cb10" data-org-language="js"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">let</span> w <span class="op">=</span> <span class="kw">new</span> <span class="at">Work</span>(data)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">function</span> <span class="at">run</span>(w) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="cf">return</span> <span class="va">Promise</span>.<span class="at">resolve</span>().<span class="at">then</span>(<span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="co">//working on Mario</span></a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="va">w</span>.<span class="at">selectSubset</span>(<span class="dv">0</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="va">w</span>.<span class="at">prepareQuery</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="cf">return</span> <span class="va">w</span>.<span class="at">doRequest</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="op">}</span>).<span class="at">then</span>(<span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb10-10" title="10">    <span class="va">w</span>.<span class="at">logResult</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-11" title="11">    <span class="va">w</span>.<span class="at">processResult</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="co">//--------------------</span></a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="co">// working on Wario</span></a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16">    <span class="va">w</span>.<span class="at">selectSubset</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-17" title="17">    <span class="va">w</span>.<span class="at">prepareQuery</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-18" title="18">    <span class="cf">return</span> <span class="va">w</span>.<span class="at">doRequest</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-19" title="19">  <span class="op">}</span>).<span class="at">then</span>(<span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb10-20" title="20">    <span class="va">w</span>.<span class="at">logResult</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-21" title="21">    <span class="va">w</span>.<span class="at">processResult</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-22" title="22">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-23" title="23"><span class="op">}</span></a>
<a class="sourceLine" id="cb10-24" title="24"></a>
<a class="sourceLine" id="cb10-25" title="25"><span class="at">run</span>(w)<span class="op">;</span></a></code></pre></div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The `async function` context is needed as long as there is no top-level `await`, which is only available in EcmaScript Modules, i.e.modules with .mjs extension and nodejs-command line flag: `–experimental-modules` (or try: –js-flags=“–harmony-top-level-await” ?), but this didn’t work for me under node v12.13.0 . However, the support for top-level-await is definitly available in the latest version of v8: <a href="https://v8.dev/features/top-level-await">https://v8.dev/features/top-level-await</a>.]</p>
<p><span id="promise-only"></span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section>
    </div>
</div>

<hr class="hide">

<div id="secondary">
    <div class="inside">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'salamynder'; // required: replace example with your forum shortname

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })
            //();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
</div>
<hr class="hide">


        <div id="ancillary">
            <div class="inside nocontent">
                <div class="block first">
                    <div class="widget">
                        <h2>Pages</h2>
                        <div class="menu-pages-container">
                            <ul id="menu-pages" class="menu">
                                <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/about-me/">About Me</a></li>
                                <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/blog/page/1/">Writing</a></li>
                            </ul>
                        </div>
                    </div>


                    <div class="widget">
                        <br>
                        <a href="/rss.xml" class="toplink feed" target="_blank"><span class="icon-feed"></span></a>
                    </div>
                </div>

                <div class="block second">
                    <div class="widget">
                        <h2>Recent Posts</h2>
                        <ul>
                            <li><a href="/2019/12/07/js-async-compilation/" title="2019-12-07-js-async-compilation">2019-12-07-js-async-compilation</a></li>
<li><a href="/2019/11/16/nodejs-simple-data-pipeline-with-async-call/" title="2019-11-16-nodejs-simple-data-pipeline-with-async-call">2019-11-16-nodejs-simple-data-pipeline-with-async-call</a></li>
<li><a href="/2014/06/22/Emacs-Orgmode-Latex/" title="2014-06-22-Emacs-Orgmode-Latex">2014-06-22-Emacs-Orgmode-Latex</a></li>

                        </ul>
                    </div>
                    <!-- <div class="widget"> -->
                    <!--     <div class="textwidget"> -->
                    <!--         <a href="/blog/page/2/" class="readmore">more...</a> -->
                    <!--     </div> -->
                    <!-- </div> -->
                </div>

                <div class="clear"></div>
            </div>
        </div>
        <hr class="hide">
        <br class="clear">
        <noscript id="deferred-styles">
            <link rel="stylesheet" type="text/css" href="/files/highlight.js/styles/github.min.css">
        </noscript>
        <script>
            var loadDeferredStyles = function() {
                var addStylesNode = document.getElementById("deferred-styles");
                var replacement = document.createElement("div");
                replacement.innerHTML = addStylesNode.textContent;
                document.body.appendChild(replacement)
                    addStylesNode.parentElement.removeChild(addStylesNode);
            };
            var raf = requestAnimationFrame || mozRequestAnimationFrame ||
            webkitRequestAnimationFrame || msRequestAnimationFrame;
            if (raf) raf(function() { window.setTimeout(loadDeferredStyles, 0); });
            else window.addEventListener('load', loadDeferredStyles);
        </script>
    </body>
    <script>
        function hljsLoaded() {
            hljs.initHighlightingOnLoad();
        }
    </script>
    <script async src="/files/highlight.js/highlight.pack.js" onload="hljsLoaded();"></script>
    <script async src="/files/main.js"></script>
</html>
